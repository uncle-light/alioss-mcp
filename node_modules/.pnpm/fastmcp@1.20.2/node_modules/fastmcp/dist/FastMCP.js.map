{"version":3,"sources":["../src/FastMCP.ts"],"sourcesContent":["import { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  CallToolRequestSchema,\n  ClientCapabilities,\n  CompleteRequestSchema,\n  CreateMessageRequestSchema,\n  ErrorCode,\n  GetPromptRequestSchema,\n  ListPromptsRequestSchema,\n  ListResourcesRequestSchema,\n  ListResourceTemplatesRequestSchema,\n  ListToolsRequestSchema,\n  McpError,\n  ReadResourceRequestSchema,\n  Root,\n  RootsListChangedNotificationSchema,\n  ServerCapabilities,\n  SetLevelRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport { zodToJsonSchema } from \"zod-to-json-schema\";\nimport { z } from \"zod\";\nimport { setTimeout as delay } from \"timers/promises\";\nimport { readFile } from \"fs/promises\";\nimport { fileTypeFromBuffer } from \"file-type\";\nimport { StrictEventEmitter } from \"strict-event-emitter-types\";\nimport { EventEmitter } from \"events\";\nimport Fuse from \"fuse.js\";\nimport { startSSEServer } from \"mcp-proxy\";\nimport { Transport } from \"@modelcontextprotocol/sdk/shared/transport.js\";\nimport parseURITemplate from \"uri-templates\";\nimport http from \"http\";\n\nexport type SSEServer = {\n  close: () => Promise<void>;\n};\n\ntype FastMCPEvents<T extends FastMCPSessionAuth> = {\n  connect: (event: { session: FastMCPSession<T> }) => void;\n  disconnect: (event: { session: FastMCPSession<T> }) => void;\n};\n\ntype FastMCPSessionEvents = {\n  rootsChanged: (event: { roots: Root[] }) => void;\n  error: (event: { error: Error }) => void;\n};\n\n/**\n * Generates an image content object from a URL, file path, or buffer.\n */\nexport const imageContent = async (\n  input: { url: string } | { path: string } | { buffer: Buffer },\n): Promise<ImageContent> => {\n  let rawData: Buffer;\n\n  if (\"url\" in input) {\n    const response = await fetch(input.url);\n\n    if (!response.ok) {\n      throw new Error(`Failed to fetch image from URL: ${response.statusText}`);\n    }\n\n    rawData = Buffer.from(await response.arrayBuffer());\n  } else if (\"path\" in input) {\n    rawData = await readFile(input.path);\n  } else if (\"buffer\" in input) {\n    rawData = input.buffer;\n  } else {\n    throw new Error(\n      \"Invalid input: Provide a valid 'url', 'path', or 'buffer'\",\n    );\n  }\n\n  const mimeType = await fileTypeFromBuffer(rawData);\n\n  const base64Data = rawData.toString(\"base64\");\n\n  return {\n    type: \"image\",\n    data: base64Data,\n    mimeType: mimeType?.mime ?? \"image/png\",\n  } as const;\n};\n\nabstract class FastMCPError extends Error {\n  public constructor(message?: string) {\n    super(message);\n    this.name = new.target.name;\n  }\n}\n\ntype Extra = unknown;\n\ntype Extras = Record<string, Extra>;\n\nexport class UnexpectedStateError extends FastMCPError {\n  public extras?: Extras;\n\n  public constructor(message: string, extras?: Extras) {\n    super(message);\n    this.name = new.target.name;\n    this.extras = extras;\n  }\n}\n\n/**\n * An error that is meant to be surfaced to the user.\n */\nexport class UserError extends UnexpectedStateError {}\n\ntype ToolParameters = z.ZodTypeAny;\n\ntype Literal = boolean | null | number | string | undefined;\n\ntype SerializableValue =\n  | Literal\n  | SerializableValue[]\n  | { [key: string]: SerializableValue };\n\ntype Progress = {\n  /**\n   * The progress thus far. This should increase every time progress is made, even if the total is unknown.\n   */\n  progress: number;\n  /**\n   * Total number of items to process (or total progress required), if known.\n   */\n  total?: number;\n};\n\ntype Context<T extends FastMCPSessionAuth> = {\n  session: T | undefined;\n  reportProgress: (progress: Progress) => Promise<void>;\n  log: {\n    debug: (message: string, data?: SerializableValue) => void;\n    error: (message: string, data?: SerializableValue) => void;\n    info: (message: string, data?: SerializableValue) => void;\n    warn: (message: string, data?: SerializableValue) => void;\n  };\n};\n\ntype TextContent = {\n  type: \"text\";\n  text: string;\n};\n\nconst TextContentZodSchema = z\n  .object({\n    type: z.literal(\"text\"),\n    /**\n     * The text content of the message.\n     */\n    text: z.string(),\n  })\n  .strict() satisfies z.ZodType<TextContent>;\n\ntype ImageContent = {\n  type: \"image\";\n  data: string;\n  mimeType: string;\n};\n\nconst ImageContentZodSchema = z\n  .object({\n    type: z.literal(\"image\"),\n    /**\n     * The base64-encoded image data.\n     */\n    data: z.string().base64(),\n    /**\n     * The MIME type of the image. Different providers may support different image types.\n     */\n    mimeType: z.string(),\n  })\n  .strict() satisfies z.ZodType<ImageContent>;\n\ntype Content = TextContent | ImageContent;\n\nconst ContentZodSchema = z.discriminatedUnion(\"type\", [\n  TextContentZodSchema,\n  ImageContentZodSchema,\n]) satisfies z.ZodType<Content>;\n\ntype ContentResult = {\n  content: Content[];\n  isError?: boolean;\n};\n\nconst ContentResultZodSchema = z\n  .object({\n    content: ContentZodSchema.array(),\n    isError: z.boolean().optional(),\n  })\n  .strict() satisfies z.ZodType<ContentResult>;\n\ntype Completion = {\n  values: string[];\n  total?: number;\n  hasMore?: boolean;\n};\n\n/**\n * https://github.com/modelcontextprotocol/typescript-sdk/blob/3164da64d085ec4e022ae881329eee7b72f208d4/src/types.ts#L983-L1003\n */\nconst CompletionZodSchema = z.object({\n  /**\n   * An array of completion values. Must not exceed 100 items.\n   */\n  values: z.array(z.string()).max(100),\n  /**\n   * The total number of completion options available. This can exceed the number of values actually sent in the response.\n   */\n  total: z.optional(z.number().int()),\n  /**\n   * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.\n   */\n  hasMore: z.optional(z.boolean()),\n}) satisfies z.ZodType<Completion>;\n\ntype Tool<T extends FastMCPSessionAuth, Params extends ToolParameters = ToolParameters> = {\n  name: string;\n  description?: string;\n  parameters?: Params;\n  execute: (\n    args: z.infer<Params>,\n    context: Context<T>,\n  ) => Promise<string | ContentResult | TextContent | ImageContent>;\n};\n\ntype ResourceResult =\n  | {\n      text: string;\n    }\n  | {\n      blob: string;\n    };\n\ntype InputResourceTemplateArgument = Readonly<{\n  name: string;\n  description?: string;\n  complete?: ArgumentValueCompleter;\n}>;\n\ntype ResourceTemplateArgument = Readonly<{\n  name: string;\n  description?: string;\n  complete?: ArgumentValueCompleter;\n}>;\n\ntype ResourceTemplate<\n  Arguments extends ResourceTemplateArgument[] = ResourceTemplateArgument[],\n> = {\n  uriTemplate: string;\n  name: string;\n  description?: string;\n  mimeType?: string;\n  arguments: Arguments;\n  complete?: (name: string, value: string) => Promise<Completion>;\n  load: (\n    args: ResourceTemplateArgumentsToObject<Arguments>,\n  ) => Promise<ResourceResult>;\n};\n\ntype ResourceTemplateArgumentsToObject<T extends { name: string }[]> = {\n  [K in T[number][\"name\"]]: string;\n};\n\ntype InputResourceTemplate<\n  Arguments extends ResourceTemplateArgument[] = ResourceTemplateArgument[],\n> = {\n  uriTemplate: string;\n  name: string;\n  description?: string;\n  mimeType?: string;\n  arguments: Arguments;\n  load: (\n    args: ResourceTemplateArgumentsToObject<Arguments>,\n  ) => Promise<ResourceResult>;\n};\n\ntype Resource = {\n  uri: string;\n  name: string;\n  description?: string;\n  mimeType?: string;\n  load: () => Promise<ResourceResult | ResourceResult[]>;\n  complete?: (name: string, value: string) => Promise<Completion>;\n};\n\ntype ArgumentValueCompleter = (value: string) => Promise<Completion>;\n\ntype InputPromptArgument = Readonly<{\n  name: string;\n  description?: string;\n  required?: boolean;\n  complete?: ArgumentValueCompleter;\n  enum?: string[];\n}>;\n\ntype PromptArgumentsToObject<T extends { name: string; required?: boolean }[]> =\n  {\n    [K in T[number][\"name\"]]: Extract<\n      T[number],\n      { name: K }\n    >[\"required\"] extends true\n      ? string\n      : string | undefined;\n  };\n\ntype InputPrompt<\n  Arguments extends InputPromptArgument[] = InputPromptArgument[],\n  Args = PromptArgumentsToObject<Arguments>,\n> = {\n  name: string;\n  description?: string;\n  arguments?: InputPromptArgument[];\n  load: (args: Args) => Promise<string>;\n};\n\ntype PromptArgument = Readonly<{\n  name: string;\n  description?: string;\n  required?: boolean;\n  complete?: ArgumentValueCompleter;\n  enum?: string[];\n}>;\n\ntype Prompt<\n  Arguments extends PromptArgument[] = PromptArgument[],\n  Args = PromptArgumentsToObject<Arguments>,\n> = {\n  arguments?: PromptArgument[];\n  complete?: (name: string, value: string) => Promise<Completion>;\n  description?: string;\n  load: (args: Args) => Promise<string>;\n  name: string;\n};\n\ntype ServerOptions<T extends FastMCPSessionAuth> = {\n  name: string;\n  version: `${number}.${number}.${number}`;\n  authenticate?: Authenticate<T>;\n};\n\ntype LoggingLevel =\n  | \"debug\"\n  | \"info\"\n  | \"notice\"\n  | \"warning\"\n  | \"error\"\n  | \"critical\"\n  | \"alert\"\n  | \"emergency\";\n\nconst FastMCPSessionEventEmitterBase: {\n  new (): StrictEventEmitter<EventEmitter, FastMCPSessionEvents>;\n} = EventEmitter;\n\nclass FastMCPSessionEventEmitter extends FastMCPSessionEventEmitterBase {}\n\ntype SamplingResponse = {\n  model: string;\n  stopReason?: \"endTurn\" | \"stopSequence\" | \"maxTokens\" | string;\n  role: \"user\" | \"assistant\";\n  content: TextContent | ImageContent;\n};\n\ntype FastMCPSessionAuth = Record<string, unknown> | undefined;\n\nexport class FastMCPSession<T extends FastMCPSessionAuth = FastMCPSessionAuth> extends FastMCPSessionEventEmitter {\n  #capabilities: ServerCapabilities = {};\n  #clientCapabilities?: ClientCapabilities;\n  #loggingLevel: LoggingLevel = \"info\";\n  #prompts: Prompt[] = [];\n  #resources: Resource[] = [];\n  #resourceTemplates: ResourceTemplate[] = [];\n  #roots: Root[] = [];\n  #server: Server;\n  #auth: T | undefined;\n\n  constructor({\n    auth,\n    name,\n    version,\n    tools,\n    resources,\n    resourcesTemplates,\n    prompts,\n  }: {\n    auth?: T;\n    name: string;\n    version: string;\n    tools: Tool<T>[];\n    resources: Resource[];\n    resourcesTemplates: InputResourceTemplate[];\n    prompts: Prompt[];\n  }) {\n    super();\n\n    this.#auth = auth;\n\n    if (tools.length) {\n      this.#capabilities.tools = {};\n    }\n\n    if (resources.length || resourcesTemplates.length) {\n      this.#capabilities.resources = {};\n    }\n\n    if (prompts.length) {\n      for (const prompt of prompts) {\n        this.addPrompt(prompt);\n      }\n\n      this.#capabilities.prompts = {};\n    }\n\n    this.#capabilities.logging = {};\n\n    this.#server = new Server(\n      { name: name, version: version },\n      { capabilities: this.#capabilities },\n    );\n\n    this.setupErrorHandling();\n    this.setupLoggingHandlers();\n    this.setupRootsHandlers();\n    this.setupCompleteHandlers();\n\n    if (tools.length) {\n      this.setupToolHandlers(tools);\n    }\n\n    if (resources.length || resourcesTemplates.length) {\n      for (const resource of resources) {\n        this.addResource(resource);\n      }\n\n      this.setupResourceHandlers(resources);\n\n      if (resourcesTemplates.length) {\n        for (const resourceTemplate of resourcesTemplates) {\n          this.addResourceTemplate(resourceTemplate);\n        }\n\n        this.setupResourceTemplateHandlers(resourcesTemplates);\n      }\n    }\n\n    if (prompts.length) {\n      this.setupPromptHandlers(prompts);\n    }\n  }\n\n  private addResource(inputResource: Resource) {\n    this.#resources.push(inputResource);\n  }\n\n  private addResourceTemplate(inputResourceTemplate: InputResourceTemplate) {\n    const completers: Record<string, ArgumentValueCompleter> = {};\n\n    for (const argument of inputResourceTemplate.arguments ?? []) {\n      if (argument.complete) {\n        completers[argument.name] = argument.complete;\n      }\n    }\n\n    const resourceTemplate = {\n      ...inputResourceTemplate,\n      complete: async (name: string, value: string) => {\n        if (completers[name]) {\n          return await completers[name](value);\n        }\n\n        return {\n          values: [],\n        };\n      },\n    };\n\n    this.#resourceTemplates.push(resourceTemplate);\n  }\n\n  private addPrompt(inputPrompt: InputPrompt) {\n    const completers: Record<string, ArgumentValueCompleter> = {};\n    const enums: Record<string, string[]> = {};\n\n    for (const argument of inputPrompt.arguments ?? []) {\n      if (argument.complete) {\n        completers[argument.name] = argument.complete;\n      }\n\n      if (argument.enum) {\n        enums[argument.name] = argument.enum;\n      }\n    }\n\n    const prompt = {\n      ...inputPrompt,\n      complete: async (name: string, value: string) => {\n        if (completers[name]) {\n          return await completers[name](value);\n        }\n\n        if (enums[name]) {\n          const fuse = new Fuse(enums[name], {\n            keys: [\"value\"],\n          });\n\n          const result = fuse.search(value);\n\n          return {\n            values: result.map((item) => item.item),\n            total: result.length,\n          };\n        }\n\n        return {\n          values: [],\n        };\n      },\n    };\n\n    this.#prompts.push(prompt);\n  }\n\n  public get clientCapabilities(): ClientCapabilities | null {\n    return this.#clientCapabilities ?? null;\n  }\n\n  public get server(): Server {\n    return this.#server;\n  }\n\n  #pingInterval: ReturnType<typeof setInterval> | null = null;\n\n  public async requestSampling(\n    message: z.infer<typeof CreateMessageRequestSchema>[\"params\"],\n  ): Promise<SamplingResponse> {\n    return this.#server.createMessage(message);\n  }\n\n  public async connect(transport: Transport) {\n    if (this.#server.transport) {\n      throw new UnexpectedStateError(\"Server is already connected\");\n    }\n\n    await this.#server.connect(transport);\n\n    let attempt = 0;\n\n    while (attempt++ < 10) {\n      const capabilities = await this.#server.getClientCapabilities();\n\n      if (capabilities) {\n        this.#clientCapabilities = capabilities;\n\n        break;\n      }\n\n      await delay(100);\n    }\n\n    if (!this.#clientCapabilities) {\n      console.warn('[warning] FastMCP could not infer client capabilities')\n    }\n\n    if (this.#clientCapabilities?.roots) {\n      const roots = await this.#server.listRoots();\n\n      this.#roots = roots.roots;\n    }\n\n    this.#pingInterval = setInterval(async () => {\n      try {\n        await this.#server.ping();\n      } catch (error) {\n        this.emit(\"error\", {\n          error: error as Error,\n        });\n      }\n    }, 1000);\n  }\n\n  public get roots(): Root[] {\n    return this.#roots;\n  }\n\n  public async close() {\n    if (this.#pingInterval) {\n      clearInterval(this.#pingInterval);\n    }\n\n    try {\n      await this.#server.close();\n    } catch (error) {\n      console.error(\"[MCP Error]\", \"could not close server\", error);\n    }\n  }\n\n  private setupErrorHandling() {\n    this.#server.onerror = (error) => {\n      console.error(\"[MCP Error]\", error);\n    };\n  }\n\n  public get loggingLevel(): LoggingLevel {\n    return this.#loggingLevel;\n  }\n\n  private setupCompleteHandlers() {\n    this.#server.setRequestHandler(CompleteRequestSchema, async (request) => {\n      if (request.params.ref.type === \"ref/prompt\") {\n        const prompt = this.#prompts.find(\n          (prompt) => prompt.name === request.params.ref.name,\n        );\n\n        if (!prompt) {\n          throw new UnexpectedStateError(\"Unknown prompt\", {\n            request,\n          });\n        }\n\n        if (!prompt.complete) {\n          throw new UnexpectedStateError(\"Prompt does not support completion\", {\n            request,\n          });\n        }\n\n        const completion = CompletionZodSchema.parse(\n          await prompt.complete(\n            request.params.argument.name,\n            request.params.argument.value,\n          ),\n        );\n\n        return {\n          completion,\n        };\n      }\n\n      if (request.params.ref.type === \"ref/resource\") {\n        const resource = this.#resourceTemplates.find(\n          (resource) => resource.uriTemplate === request.params.ref.uri,\n        );\n\n        if (!resource) {\n          throw new UnexpectedStateError(\"Unknown resource\", {\n            request,\n          });\n        }\n\n        if (!(\"uriTemplate\" in resource)) {\n          throw new UnexpectedStateError(\"Unexpected resource\");\n        }\n\n        if (!resource.complete) {\n          throw new UnexpectedStateError(\n            \"Resource does not support completion\",\n            {\n              request,\n            },\n          );\n        }\n\n        const completion = CompletionZodSchema.parse(\n          await resource.complete(\n            request.params.argument.name,\n            request.params.argument.value,\n          ),\n        );\n\n        return {\n          completion,\n        };\n      }\n\n      throw new UnexpectedStateError(\"Unexpected completion request\", {\n        request,\n      });\n    });\n  }\n\n  private setupRootsHandlers() {\n    this.#server.setNotificationHandler(\n      RootsListChangedNotificationSchema,\n      () => {\n        this.#server.listRoots().then((roots) => {\n          this.#roots = roots.roots;\n\n          this.emit(\"rootsChanged\", {\n            roots: roots.roots,\n          });\n        });\n      },\n    );\n  }\n\n  private setupLoggingHandlers() {\n    this.#server.setRequestHandler(SetLevelRequestSchema, (request) => {\n      this.#loggingLevel = request.params.level;\n\n      return {};\n    });\n  }\n\n  private setupToolHandlers(tools: Tool<T>[]) {\n    this.#server.setRequestHandler(ListToolsRequestSchema, async () => {\n      return {\n        tools: tools.map((tool) => {\n          return {\n            name: tool.name,\n            description: tool.description,\n            inputSchema: tool.parameters\n              ? zodToJsonSchema(tool.parameters)\n              : undefined,\n          };\n        }),\n      };\n    });\n\n    this.#server.setRequestHandler(CallToolRequestSchema, async (request) => {\n      const tool = tools.find((tool) => tool.name === request.params.name);\n\n      if (!tool) {\n        throw new McpError(\n          ErrorCode.MethodNotFound,\n          `Unknown tool: ${request.params.name}`,\n        );\n      }\n\n      let args: any = undefined;\n\n      if (tool.parameters) {\n        const parsed = tool.parameters.safeParse(request.params.arguments);\n\n        if (!parsed.success) {\n          throw new McpError(\n            ErrorCode.InvalidParams,\n            `Invalid ${request.params.name} parameters`,\n          );\n        }\n\n        args = parsed.data;\n      }\n\n      const progressToken = request.params?._meta?.progressToken;\n\n      let result: ContentResult;\n\n      try {\n        const reportProgress = async (progress: Progress) => {\n          await this.#server.notification({\n            method: \"notifications/progress\",\n            params: {\n              ...progress,\n              progressToken,\n            },\n          });\n        };\n\n        const log = {\n          debug: (message: string, context?: SerializableValue) => {\n            this.#server.sendLoggingMessage({\n              level: \"debug\",\n              data: {\n                message,\n                context,\n              },\n            });\n          },\n          error: (message: string, context?: SerializableValue) => {\n            this.#server.sendLoggingMessage({\n              level: \"error\",\n              data: {\n                message,\n                context,\n              },\n            });\n          },\n          info: (message: string, context?: SerializableValue) => {\n            this.#server.sendLoggingMessage({\n              level: \"info\",\n              data: {\n                message,\n                context,\n              },\n            });\n          },\n          warn: (message: string, context?: SerializableValue) => {\n            this.#server.sendLoggingMessage({\n              level: \"warning\",\n              data: {\n                message,\n                context,\n              },\n            });\n          },\n        };\n\n        const maybeStringResult = await tool.execute(args, {\n          reportProgress,\n          log,\n          session: this.#auth,\n        });\n\n        if (typeof maybeStringResult === \"string\") {\n          result = ContentResultZodSchema.parse({\n            content: [{ type: \"text\", text: maybeStringResult }],\n          });\n        } else if (\"type\" in maybeStringResult) {\n          result = ContentResultZodSchema.parse({\n            content: [maybeStringResult],\n          });\n        } else {\n          result = ContentResultZodSchema.parse(maybeStringResult);\n        }\n      } catch (error) {\n        if (error instanceof UserError) {\n          return {\n            content: [{ type: \"text\", text: error.message }],\n            isError: true,\n          };\n        }\n\n        return {\n          content: [{ type: \"text\", text: `Error: ${error}` }],\n          isError: true,\n        };\n      }\n\n      return result;\n    });\n  }\n\n  private setupResourceHandlers(resources: Resource[]) {\n    this.#server.setRequestHandler(ListResourcesRequestSchema, async () => {\n      return {\n        resources: resources.map((resource) => {\n          return {\n            uri: resource.uri,\n            name: resource.name,\n            mimeType: resource.mimeType,\n          };\n        }),\n      };\n    });\n\n    this.#server.setRequestHandler(\n      ReadResourceRequestSchema,\n      async (request) => {\n        if (\"uri\" in request.params) {\n          const resource = resources.find(\n            (resource) =>\n              \"uri\" in resource && resource.uri === request.params.uri,\n          );\n\n          if (!resource) {\n            for (const resourceTemplate of this.#resourceTemplates) {\n              const uriTemplate = parseURITemplate(\n                resourceTemplate.uriTemplate,\n              );\n\n              const match = uriTemplate.fromUri(request.params.uri);\n\n              if (!match) {\n                continue;\n              }\n\n              const uri = uriTemplate.fill(match);\n\n              const result = await resourceTemplate.load(match);\n\n              return {\n                contents: [\n                  {\n                    uri: uri,\n                    mimeType: resourceTemplate.mimeType,\n                    name: resourceTemplate.name,\n                    ...result,\n                  },\n                ],\n              };\n            }\n\n            throw new McpError(\n              ErrorCode.MethodNotFound,\n              `Unknown resource: ${request.params.uri}`,\n            );\n          }\n\n          if (!(\"uri\" in resource)) {\n            throw new UnexpectedStateError(\"Resource does not support reading\");\n          }\n\n          let maybeArrayResult: Awaited<ReturnType<Resource[\"load\"]>>;\n\n          try {\n            maybeArrayResult = await resource.load();\n          } catch (error) {\n            throw new McpError(\n              ErrorCode.InternalError,\n              `Error reading resource: ${error}`,\n              {\n                uri: resource.uri,\n              },\n            );\n          }\n\n          if (Array.isArray(maybeArrayResult)) {\n            return {\n              contents: maybeArrayResult.map((result) => ({\n                uri: resource.uri,\n                mimeType: resource.mimeType,\n                name: resource.name,\n                ...result,\n              })),\n            };\n          } else {\n            return {\n              contents: [\n                {\n                  uri: resource.uri,\n                  mimeType: resource.mimeType,\n                  name: resource.name,\n                  ...maybeArrayResult,\n                },\n              ],\n            };\n          }\n        }\n\n        throw new UnexpectedStateError(\"Unknown resource request\", {\n          request,\n        });\n      },\n    );\n  }\n\n  private setupResourceTemplateHandlers(resourceTemplates: ResourceTemplate[]) {\n    this.#server.setRequestHandler(\n      ListResourceTemplatesRequestSchema,\n      async () => {\n        return {\n          resourceTemplates: resourceTemplates.map((resourceTemplate) => {\n            return {\n              name: resourceTemplate.name,\n              uriTemplate: resourceTemplate.uriTemplate,\n            };\n          }),\n        };\n      },\n    );\n  }\n\n  private setupPromptHandlers(prompts: Prompt[]) {\n    this.#server.setRequestHandler(ListPromptsRequestSchema, async () => {\n      return {\n        prompts: prompts.map((prompt) => {\n          return {\n            name: prompt.name,\n            description: prompt.description,\n            arguments: prompt.arguments,\n            complete: prompt.complete,\n          };\n        }),\n      };\n    });\n\n    this.#server.setRequestHandler(GetPromptRequestSchema, async (request) => {\n      const prompt = prompts.find(\n        (prompt) => prompt.name === request.params.name,\n      );\n\n      if (!prompt) {\n        throw new McpError(\n          ErrorCode.MethodNotFound,\n          `Unknown prompt: ${request.params.name}`,\n        );\n      }\n\n      const args = request.params.arguments;\n\n      for (const arg of prompt.arguments ?? []) {\n        if (arg.required && !(args && arg.name in args)) {\n          throw new McpError(\n            ErrorCode.InvalidRequest,\n            `Missing required argument: ${arg.name}`,\n          );\n        }\n      }\n\n      let result: Awaited<ReturnType<Prompt[\"load\"]>>;\n\n      try {\n        result = await prompt.load(args as Record<string, string | undefined>);\n      } catch (error) {\n        throw new McpError(\n          ErrorCode.InternalError,\n          `Error loading prompt: ${error}`,\n        );\n      }\n\n      return {\n        description: prompt.description,\n        messages: [\n          {\n            role: \"user\",\n            content: { type: \"text\", text: result },\n          },\n        ],\n      };\n    });\n  }\n}\n\nconst FastMCPEventEmitterBase: {\n  new (): StrictEventEmitter<EventEmitter, FastMCPEvents<FastMCPSessionAuth>>;\n} = EventEmitter;\n\nclass FastMCPEventEmitter extends FastMCPEventEmitterBase {}\n\ntype Authenticate<T> = (request: http.IncomingMessage) => Promise<T>;\n\nexport class FastMCP<T extends Record<string, unknown> | undefined = undefined> extends FastMCPEventEmitter {\n  #options: ServerOptions<T>;\n  #prompts: InputPrompt[] = [];\n  #resources: Resource[] = [];\n  #resourcesTemplates: InputResourceTemplate[] = [];\n  #sessions: FastMCPSession<T>[] = [];\n  #sseServer: SSEServer | null = null;\n  #tools: Tool<T>[] = [];\n  #authenticate: Authenticate<T> | undefined;\n\n  constructor(public options: ServerOptions<T>) {\n    super();\n\n    this.#options = options;\n    this.#authenticate = options.authenticate;\n  }\n\n  public get sessions(): FastMCPSession<T>[] {\n    return this.#sessions;\n  }\n\n  /**\n   * Adds a tool to the server.\n   */\n  public addTool<Params extends ToolParameters>(tool: Tool<T, Params>) {\n    this.#tools.push(tool as unknown as Tool<T>);\n  }\n\n  /**\n   * Adds a resource to the server.\n   */\n  public addResource(resource: Resource) {\n    this.#resources.push(resource);\n  }\n\n  /**\n   * Adds a resource template to the server.\n   */\n  public addResourceTemplate<\n    const Args extends InputResourceTemplateArgument[],\n  >(resource: InputResourceTemplate<Args>) {\n    this.#resourcesTemplates.push(resource);\n  }\n\n  /**\n   * Adds a prompt to the server.\n   */\n  public addPrompt<const Args extends InputPromptArgument[]>(\n    prompt: InputPrompt<Args>,\n  ) {\n    this.#prompts.push(prompt);\n  }\n\n  /**\n   * Starts the server.\n   */\n  public async start(\n    options:\n      | { transportType: \"stdio\" }\n      | {\n          transportType: \"sse\";\n          sse: { endpoint: `/${string}`; port: number };\n        } = {\n      transportType: \"stdio\",\n    },\n  ) {\n    if (options.transportType === \"stdio\") {\n      const transport = new StdioServerTransport();\n\n      const session = new FastMCPSession<T>({\n        name: this.#options.name,\n        version: this.#options.version,\n        tools: this.#tools,\n        resources: this.#resources,\n        resourcesTemplates: this.#resourcesTemplates,\n        prompts: this.#prompts,\n      });\n\n      await session.connect(transport);\n\n      this.#sessions.push(session);\n\n      this.emit(\"connect\", {\n        session,\n      });\n\n    } else if (options.transportType === \"sse\") {\n      this.#sseServer = await startSSEServer<FastMCPSession<T>>({\n        endpoint: options.sse.endpoint as `/${string}`,\n        port: options.sse.port,\n        createServer: async (request) => {\n          let auth: T | undefined;\n\n          if (this.#authenticate) {\n            auth = await this.#authenticate(request);\n          }\n\n          return new FastMCPSession<T>({\n            auth,\n            name: this.#options.name,\n            version: this.#options.version,\n            tools: this.#tools,\n            resources: this.#resources,\n            resourcesTemplates: this.#resourcesTemplates,\n            prompts: this.#prompts,\n          });\n        },\n        onClose: (session) => {\n          this.emit(\"disconnect\", {\n            session,\n          });\n        },\n        onConnect: async (session) => {\n          this.#sessions.push(session);\n\n          this.emit(\"connect\", {\n            session,\n          });\n        },\n      });\n\n      console.info(\n        `server is running on SSE at http://localhost:${options.sse.port}${options.sse.endpoint}`,\n      );\n    } else {\n      throw new Error(\"Invalid transport type\");\n    }\n  }\n\n  /**\n   * Stops the server.\n   */\n  public async stop() {\n    if (this.#sseServer) {\n      this.#sseServer.close();\n    }\n  }\n}\n\nexport type { Context };\nexport type { Tool, ToolParameters };\nexport type { Content, TextContent, ImageContent, ContentResult };\nexport type { Progress, SerializableValue };\nexport type { Resource, ResourceResult };\nexport type { ResourceTemplate, ResourceTemplateArgument };\nexport type { Prompt, PromptArgument };\nexport type { InputPrompt, InputPromptArgument };\nexport type { ServerOptions, LoggingLevel };\nexport type { FastMCPEvents, FastMCPSessionEvents };\n"],"mappings":";AAAA,SAAS,cAAc;AACvB,SAAS,4BAA4B;AACrC;AAAA,EACE;AAAA,EAEA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEA;AAAA,EAEA;AAAA,OACK;AACP,SAAS,uBAAuB;AAChC,SAAS,SAAS;AAClB,SAAS,cAAc,aAAa;AACpC,SAAS,gBAAgB;AACzB,SAAS,0BAA0B;AAEnC,SAAS,oBAAoB;AAC7B,OAAO,UAAU;AACjB,SAAS,sBAAsB;AAE/B,OAAO,sBAAsB;AAoBtB,IAAM,eAAe,OAC1B,UAC0B;AAC1B,MAAI;AAEJ,MAAI,SAAS,OAAO;AAClB,UAAM,WAAW,MAAM,MAAM,MAAM,GAAG;AAEtC,QAAI,CAAC,SAAS,IAAI;AAChB,YAAM,IAAI,MAAM,mCAAmC,SAAS,UAAU,EAAE;AAAA,IAC1E;AAEA,cAAU,OAAO,KAAK,MAAM,SAAS,YAAY,CAAC;AAAA,EACpD,WAAW,UAAU,OAAO;AAC1B,cAAU,MAAM,SAAS,MAAM,IAAI;AAAA,EACrC,WAAW,YAAY,OAAO;AAC5B,cAAU,MAAM;AAAA,EAClB,OAAO;AACL,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAEA,QAAM,WAAW,MAAM,mBAAmB,OAAO;AAEjD,QAAM,aAAa,QAAQ,SAAS,QAAQ;AAE5C,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,UAAU,UAAU,QAAQ;AAAA,EAC9B;AACF;AAEA,IAAe,eAAf,cAAoC,MAAM;AAAA,EACjC,YAAY,SAAkB;AACnC,UAAM,OAAO;AACb,SAAK,OAAO,WAAW;AAAA,EACzB;AACF;AAMO,IAAM,uBAAN,cAAmC,aAAa;AAAA,EAC9C;AAAA,EAEA,YAAY,SAAiB,QAAiB;AACnD,UAAM,OAAO;AACb,SAAK,OAAO,WAAW;AACvB,SAAK,SAAS;AAAA,EAChB;AACF;AAKO,IAAM,YAAN,cAAwB,qBAAqB;AAAC;AAsCrD,IAAM,uBAAuB,EAC1B,OAAO;AAAA,EACN,MAAM,EAAE,QAAQ,MAAM;AAAA;AAAA;AAAA;AAAA,EAItB,MAAM,EAAE,OAAO;AACjB,CAAC,EACA,OAAO;AAQV,IAAM,wBAAwB,EAC3B,OAAO;AAAA,EACN,MAAM,EAAE,QAAQ,OAAO;AAAA;AAAA;AAAA;AAAA,EAIvB,MAAM,EAAE,OAAO,EAAE,OAAO;AAAA;AAAA;AAAA;AAAA,EAIxB,UAAU,EAAE,OAAO;AACrB,CAAC,EACA,OAAO;AAIV,IAAM,mBAAmB,EAAE,mBAAmB,QAAQ;AAAA,EACpD;AAAA,EACA;AACF,CAAC;AAOD,IAAM,yBAAyB,EAC5B,OAAO;AAAA,EACN,SAAS,iBAAiB,MAAM;AAAA,EAChC,SAAS,EAAE,QAAQ,EAAE,SAAS;AAChC,CAAC,EACA,OAAO;AAWV,IAAM,sBAAsB,EAAE,OAAO;AAAA;AAAA;AAAA;AAAA,EAInC,QAAQ,EAAE,MAAM,EAAE,OAAO,CAAC,EAAE,IAAI,GAAG;AAAA;AAAA;AAAA;AAAA,EAInC,OAAO,EAAE,SAAS,EAAE,OAAO,EAAE,IAAI,CAAC;AAAA;AAAA;AAAA;AAAA,EAIlC,SAAS,EAAE,SAAS,EAAE,QAAQ,CAAC;AACjC,CAAC;AAyID,IAAM,iCAEF;AAEJ,IAAM,6BAAN,cAAyC,+BAA+B;AAAC;AAWlE,IAAM,iBAAN,cAAgF,2BAA2B;AAAA,EAChH,gBAAoC,CAAC;AAAA,EACrC;AAAA,EACA,gBAA8B;AAAA,EAC9B,WAAqB,CAAC;AAAA,EACtB,aAAyB,CAAC;AAAA,EAC1B,qBAAyC,CAAC;AAAA,EAC1C,SAAiB,CAAC;AAAA,EAClB;AAAA,EACA;AAAA,EAEA,YAAY;AAAA,IACV;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAQG;AACD,UAAM;AAEN,SAAK,QAAQ;AAEb,QAAI,MAAM,QAAQ;AAChB,WAAK,cAAc,QAAQ,CAAC;AAAA,IAC9B;AAEA,QAAI,UAAU,UAAU,mBAAmB,QAAQ;AACjD,WAAK,cAAc,YAAY,CAAC;AAAA,IAClC;AAEA,QAAI,QAAQ,QAAQ;AAClB,iBAAW,UAAU,SAAS;AAC5B,aAAK,UAAU,MAAM;AAAA,MACvB;AAEA,WAAK,cAAc,UAAU,CAAC;AAAA,IAChC;AAEA,SAAK,cAAc,UAAU,CAAC;AAE9B,SAAK,UAAU,IAAI;AAAA,MACjB,EAAE,MAAY,QAAiB;AAAA,MAC/B,EAAE,cAAc,KAAK,cAAc;AAAA,IACrC;AAEA,SAAK,mBAAmB;AACxB,SAAK,qBAAqB;AAC1B,SAAK,mBAAmB;AACxB,SAAK,sBAAsB;AAE3B,QAAI,MAAM,QAAQ;AAChB,WAAK,kBAAkB,KAAK;AAAA,IAC9B;AAEA,QAAI,UAAU,UAAU,mBAAmB,QAAQ;AACjD,iBAAW,YAAY,WAAW;AAChC,aAAK,YAAY,QAAQ;AAAA,MAC3B;AAEA,WAAK,sBAAsB,SAAS;AAEpC,UAAI,mBAAmB,QAAQ;AAC7B,mBAAW,oBAAoB,oBAAoB;AACjD,eAAK,oBAAoB,gBAAgB;AAAA,QAC3C;AAEA,aAAK,8BAA8B,kBAAkB;AAAA,MACvD;AAAA,IACF;AAEA,QAAI,QAAQ,QAAQ;AAClB,WAAK,oBAAoB,OAAO;AAAA,IAClC;AAAA,EACF;AAAA,EAEQ,YAAY,eAAyB;AAC3C,SAAK,WAAW,KAAK,aAAa;AAAA,EACpC;AAAA,EAEQ,oBAAoB,uBAA8C;AACxE,UAAM,aAAqD,CAAC;AAE5D,eAAW,YAAY,sBAAsB,aAAa,CAAC,GAAG;AAC5D,UAAI,SAAS,UAAU;AACrB,mBAAW,SAAS,IAAI,IAAI,SAAS;AAAA,MACvC;AAAA,IACF;AAEA,UAAM,mBAAmB;AAAA,MACvB,GAAG;AAAA,MACH,UAAU,OAAO,MAAc,UAAkB;AAC/C,YAAI,WAAW,IAAI,GAAG;AACpB,iBAAO,MAAM,WAAW,IAAI,EAAE,KAAK;AAAA,QACrC;AAEA,eAAO;AAAA,UACL,QAAQ,CAAC;AAAA,QACX;AAAA,MACF;AAAA,IACF;AAEA,SAAK,mBAAmB,KAAK,gBAAgB;AAAA,EAC/C;AAAA,EAEQ,UAAU,aAA0B;AAC1C,UAAM,aAAqD,CAAC;AAC5D,UAAM,QAAkC,CAAC;AAEzC,eAAW,YAAY,YAAY,aAAa,CAAC,GAAG;AAClD,UAAI,SAAS,UAAU;AACrB,mBAAW,SAAS,IAAI,IAAI,SAAS;AAAA,MACvC;AAEA,UAAI,SAAS,MAAM;AACjB,cAAM,SAAS,IAAI,IAAI,SAAS;AAAA,MAClC;AAAA,IACF;AAEA,UAAM,SAAS;AAAA,MACb,GAAG;AAAA,MACH,UAAU,OAAO,MAAc,UAAkB;AAC/C,YAAI,WAAW,IAAI,GAAG;AACpB,iBAAO,MAAM,WAAW,IAAI,EAAE,KAAK;AAAA,QACrC;AAEA,YAAI,MAAM,IAAI,GAAG;AACf,gBAAM,OAAO,IAAI,KAAK,MAAM,IAAI,GAAG;AAAA,YACjC,MAAM,CAAC,OAAO;AAAA,UAChB,CAAC;AAED,gBAAM,SAAS,KAAK,OAAO,KAAK;AAEhC,iBAAO;AAAA,YACL,QAAQ,OAAO,IAAI,CAAC,SAAS,KAAK,IAAI;AAAA,YACtC,OAAO,OAAO;AAAA,UAChB;AAAA,QACF;AAEA,eAAO;AAAA,UACL,QAAQ,CAAC;AAAA,QACX;AAAA,MACF;AAAA,IACF;AAEA,SAAK,SAAS,KAAK,MAAM;AAAA,EAC3B;AAAA,EAEA,IAAW,qBAAgD;AACzD,WAAO,KAAK,uBAAuB;AAAA,EACrC;AAAA,EAEA,IAAW,SAAiB;AAC1B,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,gBAAuD;AAAA,EAEvD,MAAa,gBACX,SAC2B;AAC3B,WAAO,KAAK,QAAQ,cAAc,OAAO;AAAA,EAC3C;AAAA,EAEA,MAAa,QAAQ,WAAsB;AACzC,QAAI,KAAK,QAAQ,WAAW;AAC1B,YAAM,IAAI,qBAAqB,6BAA6B;AAAA,IAC9D;AAEA,UAAM,KAAK,QAAQ,QAAQ,SAAS;AAEpC,QAAI,UAAU;AAEd,WAAO,YAAY,IAAI;AACrB,YAAM,eAAe,MAAM,KAAK,QAAQ,sBAAsB;AAE9D,UAAI,cAAc;AAChB,aAAK,sBAAsB;AAE3B;AAAA,MACF;AAEA,YAAM,MAAM,GAAG;AAAA,IACjB;AAEA,QAAI,CAAC,KAAK,qBAAqB;AAC7B,cAAQ,KAAK,uDAAuD;AAAA,IACtE;AAEA,QAAI,KAAK,qBAAqB,OAAO;AACnC,YAAM,QAAQ,MAAM,KAAK,QAAQ,UAAU;AAE3C,WAAK,SAAS,MAAM;AAAA,IACtB;AAEA,SAAK,gBAAgB,YAAY,YAAY;AAC3C,UAAI;AACF,cAAM,KAAK,QAAQ,KAAK;AAAA,MAC1B,SAAS,OAAO;AACd,aAAK,KAAK,SAAS;AAAA,UACjB;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF,GAAG,GAAI;AAAA,EACT;AAAA,EAEA,IAAW,QAAgB;AACzB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,MAAa,QAAQ;AACnB,QAAI,KAAK,eAAe;AACtB,oBAAc,KAAK,aAAa;AAAA,IAClC;AAEA,QAAI;AACF,YAAM,KAAK,QAAQ,MAAM;AAAA,IAC3B,SAAS,OAAO;AACd,cAAQ,MAAM,eAAe,0BAA0B,KAAK;AAAA,IAC9D;AAAA,EACF;AAAA,EAEQ,qBAAqB;AAC3B,SAAK,QAAQ,UAAU,CAAC,UAAU;AAChC,cAAQ,MAAM,eAAe,KAAK;AAAA,IACpC;AAAA,EACF;AAAA,EAEA,IAAW,eAA6B;AACtC,WAAO,KAAK;AAAA,EACd;AAAA,EAEQ,wBAAwB;AAC9B,SAAK,QAAQ,kBAAkB,uBAAuB,OAAO,YAAY;AACvE,UAAI,QAAQ,OAAO,IAAI,SAAS,cAAc;AAC5C,cAAM,SAAS,KAAK,SAAS;AAAA,UAC3B,CAACA,YAAWA,QAAO,SAAS,QAAQ,OAAO,IAAI;AAAA,QACjD;AAEA,YAAI,CAAC,QAAQ;AACX,gBAAM,IAAI,qBAAqB,kBAAkB;AAAA,YAC/C;AAAA,UACF,CAAC;AAAA,QACH;AAEA,YAAI,CAAC,OAAO,UAAU;AACpB,gBAAM,IAAI,qBAAqB,sCAAsC;AAAA,YACnE;AAAA,UACF,CAAC;AAAA,QACH;AAEA,cAAM,aAAa,oBAAoB;AAAA,UACrC,MAAM,OAAO;AAAA,YACX,QAAQ,OAAO,SAAS;AAAA,YACxB,QAAQ,OAAO,SAAS;AAAA,UAC1B;AAAA,QACF;AAEA,eAAO;AAAA,UACL;AAAA,QACF;AAAA,MACF;AAEA,UAAI,QAAQ,OAAO,IAAI,SAAS,gBAAgB;AAC9C,cAAM,WAAW,KAAK,mBAAmB;AAAA,UACvC,CAACC,cAAaA,UAAS,gBAAgB,QAAQ,OAAO,IAAI;AAAA,QAC5D;AAEA,YAAI,CAAC,UAAU;AACb,gBAAM,IAAI,qBAAqB,oBAAoB;AAAA,YACjD;AAAA,UACF,CAAC;AAAA,QACH;AAEA,YAAI,EAAE,iBAAiB,WAAW;AAChC,gBAAM,IAAI,qBAAqB,qBAAqB;AAAA,QACtD;AAEA,YAAI,CAAC,SAAS,UAAU;AACtB,gBAAM,IAAI;AAAA,YACR;AAAA,YACA;AAAA,cACE;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAEA,cAAM,aAAa,oBAAoB;AAAA,UACrC,MAAM,SAAS;AAAA,YACb,QAAQ,OAAO,SAAS;AAAA,YACxB,QAAQ,OAAO,SAAS;AAAA,UAC1B;AAAA,QACF;AAEA,eAAO;AAAA,UACL;AAAA,QACF;AAAA,MACF;AAEA,YAAM,IAAI,qBAAqB,iCAAiC;AAAA,QAC9D;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEQ,qBAAqB;AAC3B,SAAK,QAAQ;AAAA,MACX;AAAA,MACA,MAAM;AACJ,aAAK,QAAQ,UAAU,EAAE,KAAK,CAAC,UAAU;AACvC,eAAK,SAAS,MAAM;AAEpB,eAAK,KAAK,gBAAgB;AAAA,YACxB,OAAO,MAAM;AAAA,UACf,CAAC;AAAA,QACH,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,uBAAuB;AAC7B,SAAK,QAAQ,kBAAkB,uBAAuB,CAAC,YAAY;AACjE,WAAK,gBAAgB,QAAQ,OAAO;AAEpC,aAAO,CAAC;AAAA,IACV,CAAC;AAAA,EACH;AAAA,EAEQ,kBAAkB,OAAkB;AAC1C,SAAK,QAAQ,kBAAkB,wBAAwB,YAAY;AACjE,aAAO;AAAA,QACL,OAAO,MAAM,IAAI,CAAC,SAAS;AACzB,iBAAO;AAAA,YACL,MAAM,KAAK;AAAA,YACX,aAAa,KAAK;AAAA,YAClB,aAAa,KAAK,aACd,gBAAgB,KAAK,UAAU,IAC/B;AAAA,UACN;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AAED,SAAK,QAAQ,kBAAkB,uBAAuB,OAAO,YAAY;AACvE,YAAM,OAAO,MAAM,KAAK,CAACC,UAASA,MAAK,SAAS,QAAQ,OAAO,IAAI;AAEnE,UAAI,CAAC,MAAM;AACT,cAAM,IAAI;AAAA,UACR,UAAU;AAAA,UACV,iBAAiB,QAAQ,OAAO,IAAI;AAAA,QACtC;AAAA,MACF;AAEA,UAAI,OAAY;AAEhB,UAAI,KAAK,YAAY;AACnB,cAAM,SAAS,KAAK,WAAW,UAAU,QAAQ,OAAO,SAAS;AAEjE,YAAI,CAAC,OAAO,SAAS;AACnB,gBAAM,IAAI;AAAA,YACR,UAAU;AAAA,YACV,WAAW,QAAQ,OAAO,IAAI;AAAA,UAChC;AAAA,QACF;AAEA,eAAO,OAAO;AAAA,MAChB;AAEA,YAAM,gBAAgB,QAAQ,QAAQ,OAAO;AAE7C,UAAI;AAEJ,UAAI;AACF,cAAM,iBAAiB,OAAO,aAAuB;AACnD,gBAAM,KAAK,QAAQ,aAAa;AAAA,YAC9B,QAAQ;AAAA,YACR,QAAQ;AAAA,cACN,GAAG;AAAA,cACH;AAAA,YACF;AAAA,UACF,CAAC;AAAA,QACH;AAEA,cAAM,MAAM;AAAA,UACV,OAAO,CAAC,SAAiB,YAAgC;AACvD,iBAAK,QAAQ,mBAAmB;AAAA,cAC9B,OAAO;AAAA,cACP,MAAM;AAAA,gBACJ;AAAA,gBACA;AAAA,cACF;AAAA,YACF,CAAC;AAAA,UACH;AAAA,UACA,OAAO,CAAC,SAAiB,YAAgC;AACvD,iBAAK,QAAQ,mBAAmB;AAAA,cAC9B,OAAO;AAAA,cACP,MAAM;AAAA,gBACJ;AAAA,gBACA;AAAA,cACF;AAAA,YACF,CAAC;AAAA,UACH;AAAA,UACA,MAAM,CAAC,SAAiB,YAAgC;AACtD,iBAAK,QAAQ,mBAAmB;AAAA,cAC9B,OAAO;AAAA,cACP,MAAM;AAAA,gBACJ;AAAA,gBACA;AAAA,cACF;AAAA,YACF,CAAC;AAAA,UACH;AAAA,UACA,MAAM,CAAC,SAAiB,YAAgC;AACtD,iBAAK,QAAQ,mBAAmB;AAAA,cAC9B,OAAO;AAAA,cACP,MAAM;AAAA,gBACJ;AAAA,gBACA;AAAA,cACF;AAAA,YACF,CAAC;AAAA,UACH;AAAA,QACF;AAEA,cAAM,oBAAoB,MAAM,KAAK,QAAQ,MAAM;AAAA,UACjD;AAAA,UACA;AAAA,UACA,SAAS,KAAK;AAAA,QAChB,CAAC;AAED,YAAI,OAAO,sBAAsB,UAAU;AACzC,mBAAS,uBAAuB,MAAM;AAAA,YACpC,SAAS,CAAC,EAAE,MAAM,QAAQ,MAAM,kBAAkB,CAAC;AAAA,UACrD,CAAC;AAAA,QACH,WAAW,UAAU,mBAAmB;AACtC,mBAAS,uBAAuB,MAAM;AAAA,YACpC,SAAS,CAAC,iBAAiB;AAAA,UAC7B,CAAC;AAAA,QACH,OAAO;AACL,mBAAS,uBAAuB,MAAM,iBAAiB;AAAA,QACzD;AAAA,MACF,SAAS,OAAO;AACd,YAAI,iBAAiB,WAAW;AAC9B,iBAAO;AAAA,YACL,SAAS,CAAC,EAAE,MAAM,QAAQ,MAAM,MAAM,QAAQ,CAAC;AAAA,YAC/C,SAAS;AAAA,UACX;AAAA,QACF;AAEA,eAAO;AAAA,UACL,SAAS,CAAC,EAAE,MAAM,QAAQ,MAAM,UAAU,KAAK,GAAG,CAAC;AAAA,UACnD,SAAS;AAAA,QACX;AAAA,MACF;AAEA,aAAO;AAAA,IACT,CAAC;AAAA,EACH;AAAA,EAEQ,sBAAsB,WAAuB;AACnD,SAAK,QAAQ,kBAAkB,4BAA4B,YAAY;AACrE,aAAO;AAAA,QACL,WAAW,UAAU,IAAI,CAAC,aAAa;AACrC,iBAAO;AAAA,YACL,KAAK,SAAS;AAAA,YACd,MAAM,SAAS;AAAA,YACf,UAAU,SAAS;AAAA,UACrB;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AAED,SAAK,QAAQ;AAAA,MACX;AAAA,MACA,OAAO,YAAY;AACjB,YAAI,SAAS,QAAQ,QAAQ;AAC3B,gBAAM,WAAW,UAAU;AAAA,YACzB,CAACD,cACC,SAASA,aAAYA,UAAS,QAAQ,QAAQ,OAAO;AAAA,UACzD;AAEA,cAAI,CAAC,UAAU;AACb,uBAAW,oBAAoB,KAAK,oBAAoB;AACtD,oBAAM,cAAc;AAAA,gBAClB,iBAAiB;AAAA,cACnB;AAEA,oBAAM,QAAQ,YAAY,QAAQ,QAAQ,OAAO,GAAG;AAEpD,kBAAI,CAAC,OAAO;AACV;AAAA,cACF;AAEA,oBAAM,MAAM,YAAY,KAAK,KAAK;AAElC,oBAAM,SAAS,MAAM,iBAAiB,KAAK,KAAK;AAEhD,qBAAO;AAAA,gBACL,UAAU;AAAA,kBACR;AAAA,oBACE;AAAA,oBACA,UAAU,iBAAiB;AAAA,oBAC3B,MAAM,iBAAiB;AAAA,oBACvB,GAAG;AAAA,kBACL;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAEA,kBAAM,IAAI;AAAA,cACR,UAAU;AAAA,cACV,qBAAqB,QAAQ,OAAO,GAAG;AAAA,YACzC;AAAA,UACF;AAEA,cAAI,EAAE,SAAS,WAAW;AACxB,kBAAM,IAAI,qBAAqB,mCAAmC;AAAA,UACpE;AAEA,cAAI;AAEJ,cAAI;AACF,+BAAmB,MAAM,SAAS,KAAK;AAAA,UACzC,SAAS,OAAO;AACd,kBAAM,IAAI;AAAA,cACR,UAAU;AAAA,cACV,2BAA2B,KAAK;AAAA,cAChC;AAAA,gBACE,KAAK,SAAS;AAAA,cAChB;AAAA,YACF;AAAA,UACF;AAEA,cAAI,MAAM,QAAQ,gBAAgB,GAAG;AACnC,mBAAO;AAAA,cACL,UAAU,iBAAiB,IAAI,CAAC,YAAY;AAAA,gBAC1C,KAAK,SAAS;AAAA,gBACd,UAAU,SAAS;AAAA,gBACnB,MAAM,SAAS;AAAA,gBACf,GAAG;AAAA,cACL,EAAE;AAAA,YACJ;AAAA,UACF,OAAO;AACL,mBAAO;AAAA,cACL,UAAU;AAAA,gBACR;AAAA,kBACE,KAAK,SAAS;AAAA,kBACd,UAAU,SAAS;AAAA,kBACnB,MAAM,SAAS;AAAA,kBACf,GAAG;AAAA,gBACL;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAEA,cAAM,IAAI,qBAAqB,4BAA4B;AAAA,UACzD;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,8BAA8B,mBAAuC;AAC3E,SAAK,QAAQ;AAAA,MACX;AAAA,MACA,YAAY;AACV,eAAO;AAAA,UACL,mBAAmB,kBAAkB,IAAI,CAAC,qBAAqB;AAC7D,mBAAO;AAAA,cACL,MAAM,iBAAiB;AAAA,cACvB,aAAa,iBAAiB;AAAA,YAChC;AAAA,UACF,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,oBAAoB,SAAmB;AAC7C,SAAK,QAAQ,kBAAkB,0BAA0B,YAAY;AACnE,aAAO;AAAA,QACL,SAAS,QAAQ,IAAI,CAAC,WAAW;AAC/B,iBAAO;AAAA,YACL,MAAM,OAAO;AAAA,YACb,aAAa,OAAO;AAAA,YACpB,WAAW,OAAO;AAAA,YAClB,UAAU,OAAO;AAAA,UACnB;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AAED,SAAK,QAAQ,kBAAkB,wBAAwB,OAAO,YAAY;AACxE,YAAM,SAAS,QAAQ;AAAA,QACrB,CAACD,YAAWA,QAAO,SAAS,QAAQ,OAAO;AAAA,MAC7C;AAEA,UAAI,CAAC,QAAQ;AACX,cAAM,IAAI;AAAA,UACR,UAAU;AAAA,UACV,mBAAmB,QAAQ,OAAO,IAAI;AAAA,QACxC;AAAA,MACF;AAEA,YAAM,OAAO,QAAQ,OAAO;AAE5B,iBAAW,OAAO,OAAO,aAAa,CAAC,GAAG;AACxC,YAAI,IAAI,YAAY,EAAE,QAAQ,IAAI,QAAQ,OAAO;AAC/C,gBAAM,IAAI;AAAA,YACR,UAAU;AAAA,YACV,8BAA8B,IAAI,IAAI;AAAA,UACxC;AAAA,QACF;AAAA,MACF;AAEA,UAAI;AAEJ,UAAI;AACF,iBAAS,MAAM,OAAO,KAAK,IAA0C;AAAA,MACvE,SAAS,OAAO;AACd,cAAM,IAAI;AAAA,UACR,UAAU;AAAA,UACV,yBAAyB,KAAK;AAAA,QAChC;AAAA,MACF;AAEA,aAAO;AAAA,QACL,aAAa,OAAO;AAAA,QACpB,UAAU;AAAA,UACR;AAAA,YACE,MAAM;AAAA,YACN,SAAS,EAAE,MAAM,QAAQ,MAAM,OAAO;AAAA,UACxC;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AACF;AAEA,IAAM,0BAEF;AAEJ,IAAM,sBAAN,cAAkC,wBAAwB;AAAC;AAIpD,IAAM,UAAN,cAAiF,oBAAoB;AAAA,EAU1G,YAAmB,SAA2B;AAC5C,UAAM;AADW;AAGjB,SAAK,WAAW;AAChB,SAAK,gBAAgB,QAAQ;AAAA,EAC/B;AAAA,EAdA;AAAA,EACA,WAA0B,CAAC;AAAA,EAC3B,aAAyB,CAAC;AAAA,EAC1B,sBAA+C,CAAC;AAAA,EAChD,YAAiC,CAAC;AAAA,EAClC,aAA+B;AAAA,EAC/B,SAAoB,CAAC;AAAA,EACrB;AAAA,EASA,IAAW,WAAgC;AACzC,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKO,QAAuC,MAAuB;AACnE,SAAK,OAAO,KAAK,IAA0B;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA,EAKO,YAAY,UAAoB;AACrC,SAAK,WAAW,KAAK,QAAQ;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA,EAKO,oBAEL,UAAuC;AACvC,SAAK,oBAAoB,KAAK,QAAQ;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA,EAKO,UACL,QACA;AACA,SAAK,SAAS,KAAK,MAAM;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA,EAKA,MAAa,MACX,UAKQ;AAAA,IACN,eAAe;AAAA,EACjB,GACA;AACA,QAAI,QAAQ,kBAAkB,SAAS;AACrC,YAAM,YAAY,IAAI,qBAAqB;AAE3C,YAAM,UAAU,IAAI,eAAkB;AAAA,QACpC,MAAM,KAAK,SAAS;AAAA,QACpB,SAAS,KAAK,SAAS;AAAA,QACvB,OAAO,KAAK;AAAA,QACZ,WAAW,KAAK;AAAA,QAChB,oBAAoB,KAAK;AAAA,QACzB,SAAS,KAAK;AAAA,MAChB,CAAC;AAED,YAAM,QAAQ,QAAQ,SAAS;AAE/B,WAAK,UAAU,KAAK,OAAO;AAE3B,WAAK,KAAK,WAAW;AAAA,QACnB;AAAA,MACF,CAAC;AAAA,IAEH,WAAW,QAAQ,kBAAkB,OAAO;AAC1C,WAAK,aAAa,MAAM,eAAkC;AAAA,QACxD,UAAU,QAAQ,IAAI;AAAA,QACtB,MAAM,QAAQ,IAAI;AAAA,QAClB,cAAc,OAAO,YAAY;AAC/B,cAAI;AAEJ,cAAI,KAAK,eAAe;AACtB,mBAAO,MAAM,KAAK,cAAc,OAAO;AAAA,UACzC;AAEA,iBAAO,IAAI,eAAkB;AAAA,YAC3B;AAAA,YACA,MAAM,KAAK,SAAS;AAAA,YACpB,SAAS,KAAK,SAAS;AAAA,YACvB,OAAO,KAAK;AAAA,YACZ,WAAW,KAAK;AAAA,YAChB,oBAAoB,KAAK;AAAA,YACzB,SAAS,KAAK;AAAA,UAChB,CAAC;AAAA,QACH;AAAA,QACA,SAAS,CAAC,YAAY;AACpB,eAAK,KAAK,cAAc;AAAA,YACtB;AAAA,UACF,CAAC;AAAA,QACH;AAAA,QACA,WAAW,OAAO,YAAY;AAC5B,eAAK,UAAU,KAAK,OAAO;AAE3B,eAAK,KAAK,WAAW;AAAA,YACnB;AAAA,UACF,CAAC;AAAA,QACH;AAAA,MACF,CAAC;AAED,cAAQ;AAAA,QACN,gDAAgD,QAAQ,IAAI,IAAI,GAAG,QAAQ,IAAI,QAAQ;AAAA,MACzF;AAAA,IACF,OAAO;AACL,YAAM,IAAI,MAAM,wBAAwB;AAAA,IAC1C;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAa,OAAO;AAClB,QAAI,KAAK,YAAY;AACnB,WAAK,WAAW,MAAM;AAAA,IACxB;AAAA,EACF;AACF;","names":["prompt","resource","tool"]}